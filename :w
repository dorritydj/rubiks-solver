type Side = [[u8; 3]; 3];
type Cube = (Side, Side, Side, Side, Side, Side);

fn main() {
    // w
    let front: Side = [[0,0,0],[0,0,0],[0,0,0]];
    // g
    let top: Side = [[1,1,1],[1,1,1],[1,1,1]];
    // o
    let right: Side = [[2,2,2],[2,2,2],[2,2,2]];
    // b
    let bottom: Side = [[3,3,3],[3,3,3],[3,3,3]];
    // r
    let left: Side = [[4,4,4],[4,4,4],[4,4,4]];
    // y
    let back: Side = [[5,5,5],[5,5,5],[5,5,5]];

    let mut cube: Cube = (front, top, right, bottom, left, back);
    cube = rotate_clockwise(cube);

    println!("{:?}", cube);
}
// Notes:
// - for any given Side, side[1][1] should never move (center square)

// TODO: make generic for any side
fn rotate_clockwise(mut cube: Cube) -> Cube {
    let (mut front, top, right, bottom, left, back) = cube;

    // shift the front face
    let [mut top_f, mut mid, mut bot] = front;
    let (i_top, i_bottom) = (top[2], bot[0]);

    top.rotate_right(1);
    top[0] = mid[0];
    mid[0] = i_bottom;

    bot.rotate_left(1);
    bot[2] = mid[2];
    mid[2] = i_top;

    front = [top, mid, bot];
    cube.0 = front;
    // end shifting front face

    // adjust sides
    let top_r = top[2];
    let right_r = [right[0][0], right[1][0], right[2][0]];
    let bot_r = bottom[0];
    let left_r = [left[0][0], left[1][2], left[2][2]];

    println!("top: {:?} right {:?} bot {:?} left {:?}", top_r, right_r, bot_r, left_r);

    return cube;
}
